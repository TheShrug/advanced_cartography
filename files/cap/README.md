# Capture Function

'capture.dll' provides the screenshot function. It will take a screenshot of whatever window is in focus when called (since captures are triggered by in-game movement, this generally works pretty well). It then shrinks it to the virtual resolution and compresses it to jpg using libjpeg's turbojpeg api. If this isn't done, then the files become too wide for stitcher to handle once you've explored about half the in-game world (assuming your virtual resolution is about 1/3 your window resolution, often it's even less). With this method you get can explore the entire main world and about 1.5 parallel worlds before the image starts needing to be shrunk even more, the files are a lot smaller and faster to write, and the quality loss is minimal.

## capture_mt
'capture_mt.dll' now works, but provides only a slight improvement, if any, in terms of performance over single-threaded. this is likely because only the second half of the screenshot process (the compression to jpg from bmp) is actually passed to the winapi threadpool, the first half still needs to be done in a single threaded state. That said, when timing this using the commented out sections of init.lua, capture.dll usually takes from 0.01 to 0.02s and capture_mt.dll takes 0.006 (which should indicate that the main speed bottleneck is in fact the compression, and the multithreading is working as intended and everything should be much faster), though actual gameplay doesn't reflect that. So it's possible that my implementation of the winapi threapool is somehow wrong, and despite creating a dedicated threadpool with it's own environment the compressions are still executing in the noita threadpool and slowing everything down, who knows. 
